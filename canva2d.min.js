/**
 * Name         : Canva2d.js
 * @author      : Mirielle S. (codeBreaker!)
 * Last Modified: 09.09.2020
 * Revision     : 0.0.2
 * Minified with tersser
 * @url https://gist.github.com/gaearon/42a2ffa41b8319948f9be4076286e1f3
 * 
 * MIT License
 * 
 * Copyright (c) 2020 CodeBreaker
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 */


let CURRENT_CONTEXT,CURRENT_SCENE;window.requestAnimationFrame=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||function(t){window.setTimeout(t,1e3/60)},CanvasRenderingContext2D.prototype.__proto__={clearColor(t,e,i,s,n){this.fillStyle=n,void 0!==n?this.fillRect(t,e,i,s):this.clearRect(t,e,i,s)},Joystick2dArc(t,e,i,s,n,h=0){this.save(),this.lineWidth=h,this.strokeStyle=n||s,this.fillStyle=s,this.beginPath(),this.arc(t,e,i,0,2*Math.PI),this.closePath(),"none"!==n&&""!==n&&this.stroke(),void 0!==s&&"none"!==s&&""!==s&&this.fill(),this.restore()}};const Vector=function(t,e){this.x=t,this.y=e,this.magnitude=Math.hypot(this.x,this.y),this.angle=Math.atan2(this.y,this.x)};Vector.prototype={normalise(){this.x/=this.magnitude,this.y/=this.magnitude},add(t){let e=this.x+t.x,i=this.y+t.y;return new Vector(e,i)},subtract(t){let e=this.x-t.x,i=this.y-t.y;return new Vector(e,i)},multiply(t){let e=this.x*t.x,i=this.y*t.y;return new Vector(e,i)},dot(t){return this.x*t.x+this.y*t.y}},Vector.__proto__={getDist:(t,e)=>new Vector(e.x,e.y).subtract({x:t.x,y:t.y}).magnitude,getPolarCoord(t=0,e=0){let i=Math.cos(t)*e,s=Math.sin(t)*e;return new Vector(i,s)}};class Collision{static circle(t,e){return Vector.getDist(t,e)<t.r+e.r}static rect(t,e){return t.x+t.w>e.x&&e.x+e.w>t.x&&t.y+t.h>e.y&&e.y+e.h>t.y}static rectCircle(t,e){var i=Math.abs(e.x-(t.x+.5*t.w)),s=Math.abs(e.y-(t.y+.5*t.h));return!(i>e.r+.5*t.w)&&(!(s>e.r+.5*t.h)&&(i<=t.w||(s<=t.h||(i=i-t.w)*i+(s=s-t.h)*s<=e.r*e.r)))}static lineIntercept(t,e){let i,s,n,h,a,o;return i=new Vector(t.x1,t.y1).subtract({x:t.x0,y:t.y0}),s=new Vector(e.x1,e.y1).subtract({x:e.x0,y:e.y0}),0!=(h=i.x*s.y-i.y*s.x)&&(n={x:t.x0-e.x0,y:t.y0-e.y0},(o=(i.x*n.y-i.y*n.x)/h)>=0&&o<=1&&((a=(s.x*n.y-s.y*n.x)/h)>=0&&a<=1))}static lineInterceptCircle(t,e){let i=new Vector(e.x,e.y).subtract({x:t.x0,y:t.y0}),s=new Vector(t.x1,t.y1).subtract({x:t.x0,y:t.y0}),n=i.dot(s)/s.dot(s),h=t.x0+s.x*n,a=t.y0+s.y*n;return n<0&&(h=t.x0,a=t.y0),n>1&&(h=t.x1,a=t.y1),new Vector(e.x-h,e.y-a).dot({x:e.x-h,y:e.y-a})<e.r*e.r}static lineInterceptRect(t,e){const i=(t,e)=>{let i=t.x0,s=t.y0,n=t.x1,h=t.y1,a=e.x0,o=e.y0,r=e.x1,c=e.y1,l=(r-a)*(s-o)-(c-o)*(i-a),y=(n-i)*(s-o)-(h-s)*(i-a),x=(c-o)*(n-i)-(r-a)*(h-s);return 0==l&&0==y&&0==x?null:0==x?null:(y/=x,(l/=x)>=0&&l<=1&&y>=0&&y<=1)};return!!i(t,{x0:e.x,y0:e.y,x1:e.x+e.w,y1:e.y+e.h})||(!!i(t,{x0:e.x+e.w,y0:e.y+e.h,x1:e.x+e.w,y1:e.y+e.h})||(!!i(t,{x0:e.x+e.w,y0:e.y+e.h,x1:e.x,y1:e.y+e.h})||!!i(t,{x0:e.x,y0:e.y+e.h,x1:e.x,y1:e.y})))}static pointAtArc(t,e){let i=new Vector(t.x,t.y).subtract({x:e.x,y:e.y}),s=i.dot(i),n=e.r1*e.r1;if(s<e.r0*e.r0||s>n)return!1;let h=(i.angle+2*Math.PI)%(2*Math.PI);return h>=e.angle0&&h<=e.angle1}static pointAtWedge(t,e){let i=new Vector(t.x,t.y).subtract({x:e.x,y:e.y}),s=e.r*e.r;if(i.x*i.x+i.y*i.y>s)return!1;let n=(i.angle+2*Math.PI)%(2*Math.PI);return n>=e.angle0&&n<=e.angle1}static pointAtCircle(t,e){let i=new Vector(e.x,e.y).subtract({x:t.x,y:t.y});return i.x*i.x+i.y*i.y<e.r*e.r}static pointAtCircleCentre(t,e){let i=new Vector(e.x,e.y).subtract({x:t.x,y:t.y});return i.x*i.x+i.y*i.y<e.r}static pointAtRect(t,e){return t.x>e.x&&t.x<e.x+e.w&&t.y>e.y&&t.y<e.y+e.h}static pointAtSemiRect(t,e){return t.x>e.x&&t.x<e.x+.05*e.w&&t.y>e.y&&t.y<e.y+.05*e.h}static elastic(t,e){const i=(t,e)=>({x:t.x*Math.cos(e)-t.y*Math.sin(e),y:t.x*Math.sin(e)+t.y*Math.cos(e)});let s=new Vector(t.vel.x,t.vel.y).subtract({x:e.vel.x,y:e.vel.y}),n=new Vector(e.x,e.y).subtract({x:t.x,y:t.y});if(n.dot(s)>=0){let s=-Math.atan2(n.y,n.x);const h=t.m,a=e.m,o=i(t.vel,s),r=i(e.vel,s),c={x:(h-a)*o.x/(h+a)+2*a*r.x/(h+a),y:o.y},l={x:2*h*o.x/(h+a)+(a-h)*r.x/(h+a),y:r.y},y=i(c,-s),x=i(l,-s);t.vel=new Vector(y.x,y.y),e.vel=new Vector(x.x,x.y)}}}const Motion={translateX:0,translateY:0,moveTo(t,e,i){let s=new Vector(e.x,e.y).subtract({x:t.x,y:t.y}),n=Vector.getPolarCoord(s.angle,i);t.x+=n.x,t.y+=n.y},reverseVel(t,e="x"){"x"===e.toLowerCase()?t.vel.x=-t.vel.x:"y"===e.toLowerCase()&&(t.vel.y=-t.vel.y)},addFriction(t,e=.8,i="y"){"x"===i.toLowerCase()?t.vel.x*=e:t.vel.y*=e},addGravity(t,e=0){t.vel.y+=e},addAcceleration(t,e,i="x"){"x"===i.toLowerCase()?t.vel.x+=e:t.vel.y+=e},moveToBezierCurve(t,e,i){let s=3*(t.x1-t.x0),n=3*(e.x0-t.x1)-s,h=e.x1-t.x0-s-n,a=3*(t.y1-t.y0),o=3*(e.y0-t.y1)-a,r=e.y1-t.y0-a-o;return{x:h*(i*i*i)+n*(i*i)+s*i+t.x0,y:r*(i*i*i)+o*(i*i)+a*i+t.y0}},easeOut(t,e,i){let s=new Vector(e.x,e.y).subtract({x:t.x,y:t.y});t.vel.x=s.magnitude*i,t.vel.y=s.magnitude*i;let n=Vector.getPolarCoord(s.angle,t.vel.x);t.x+=n.x,t.y+=n.y},easeIn(t,e,i){let s=new Vector(e.x,e.y).subtract({x:t.x,y:t.y});t.vel.x+=i;let n=Vector.getPolarCoord(s.angle,t.vel.x);t.x+=n.x,t.y+=n.y},translate(t,e){this.translateX=t,this.translateY=e},rotate(t,e=0,i=0){let s=Vector.getPolarCoord(e,i);t.x=this.translateX+s.x,t.y=this.translateY+s.y}};Math.__proto__={randRange(t=0,e=1){return this.random()*(e-t+1)+t},randFromArray(t){return t[this.random()*t.length|0]},toRadian(t){return t*this.PI/180},toDegree(t){return 180*t/this.PI}};class Swipe{constructor({element:t,type:e="default"}){if(this.element=t,this.direction=null,this.isActive=!1,this.pos=new Vector(0,0),void 0!==e)switch(e.toLowerCase()){case"touch":this.touch();break;case"mouse":this.mouse();break;case"default":"ontouchstart"in window?this.touch():"onmousedown"in window&&this.mouse();break;default:throw new Error(`Swipe of type "${e}" does not exist`)}else"ontouchstart"in window?this.touch():"onmousedown"in window&&this.mouse()}checkSwipe(t,e){let i=e.subtract(t);Math.abs(i.x)>Math.abs(i.y)?i.x<0?this.direction="left":this.direction="right":i.y<0?this.direction="up":this.direction="down"}touch(){this.element.addEventListener("touchstart",t=>{this.isActive=!0,this.pos=new Vector(t.touches[0].pageX,t.touches[0].pageY)}),this.element.addEventListener("touchmove",t=>{this.checkSwipe(this.pos,new Vector(t.touches[0].pageX,t.touches[0].pageY)),this.element.dispatchEvent(new CustomEvent("swipe",{detail:{e:t,isActive:this.isActive,originX:this.pos.x,originY:this.pos.y,clientX:t.touches[0].pageX,clientY:t.touches[0].pageY,direction:this.direction}})),t.preventDefault()}),this.element.addEventListener("touchend",()=>{this.isActive=!1,this.pos=new Vector(0,0)})}mouse(){this.element.addEventListener("mousedown",t=>{this.isActive=!0,this.pos=new Vector(t.clientX,t.clientY)}),this.element.addEventListener("mousemove",t=>{this.isActive&&(this.checkSwipe(this.pos,new Vector(t.clientX,t.clientY)),this.element.dispatchEvent(new CustomEvent("swipe",{detail:{e:t,isActive:this.isActive,originX:this.pos.x,originY:this.pos.y,clientX:t.clientX,clientY:t.clientY,direction:this.direction}})))}),this.element.addEventListener("mouseup",()=>{this.isActive=!1,this.pos=new Vector(0,0)})}}class JoyStick{constructor({canvas:t,x:e=0,y:i=0,dynamic:s=!0,innerRadius:n=15,outerRadius:h=50,color:a="lightgray",lineWidth:o=4,outlineColor:r="#222",backgroundColor:c="none",backgroundOutlineColor:l="#222",backgroundLineWidth:y=4,fadeTimeout:x=100,type:d="default"}){this.canvas=t;try{this.ctx=this.canvas.getContext("2d")}catch(t){throw new Error("Joystick Failed to intialize CANVAS")}if(this.dynamic=!1!==s,this.origin=new Vector(e,i),this.pos=new Vector(e,i),this.direction=null,this.color=a,this.lineWidth=o,this.outlineColor=r,this.innerRadius=n,this.backgroundColor=c,this.backgroundOutlineColor=l,this.backgroundLineWidth=y,this.outerRadius=h,this.isActive=!1,this.timeSpan=x,this.timeSpanCounter=this.timeSpan,this.speedCounter=0,this.isDisplay=!1,this.isFading=!1,this.alpha=1,void 0!==d)switch(d.toLowerCase()){case"touch":this.touch();break;case"mouse":this.mouse();break;case"default":"ontouchstart"in window?this.touch():"onmousedown"in window&&this.mouse();break;default:console.error(`${params.type} types does not exists`)}else"ontouchstart"in window?this.touch():"onmousedown"in window&&this.mouse()}draw(){this.ctx.save(),this.ctx.globalAlpha=this.alpha,this.ctx.Joystick2dArc(this.origin.x,this.origin.y,this.outerRadius,this.backgroundColor,this.backgroundOutlineColor,this.backgroundLineWidth),this.ctx.Joystick2dArc(this.pos.x,this.pos.y,this.innerRadius,this.color,this.outlineColor,this.lineWidth),this.ctx.restore()}fadeIn(){this.isFading&&(this.timeSpanCounter-=1,this.alpha=Math.abs(this.timeSpanCounter/this.timeSpan),this.alpha<=0&&(this.isDisplay=!1,this.timeSpanCounter=this.timeSpan))}checkSwipe(t,e){let i=e.subtract(t);Math.abs(i.x)>Math.abs(i.y)?i.x<0?this.direction="left":this.direction="right":i.y<0?this.direction="up":this.direction="down"}mouse(){this.canvas.addEventListener("mousedown",t=>{if(this.dynamic){let e=this.canvas.getBoundingClientRect();this.origin=new Vector(t.clientX,t.clientY).subtract({x:e.x,y:e.y}),this.pos=new Vector(t.clientX,t.clientY).subtract({x:e.x,y:e.y}),this.isDisplay=!0,this.isFading=!1,this.alpha=1}this.isActive=!0}),this.canvas.addEventListener("mousemove",t=>{if(this.isActive){let e=this.canvas.getBoundingClientRect(),i=new Vector(t.clientX,t.clientY).subtract({x:e.x,y:e.y}).subtract(this.origin);this.checkSwipe(this.origin,new Vector(t.clientX,t.clientY));let s=Math.min(i.magnitude,this.outerRadius);this.pos.x=this.origin.x+Math.cos(i.angle)*s,this.pos.y=this.origin.y+Math.sin(i.angle)*s,this.canvas.dispatchEvent(new CustomEvent("joystick",{detail:{e:t,angle:i.angle,magnitude:i.magnitude,direction:this.direction,originX:this.origin.x,originY:this.origin.y,clientX:t.clientX,clientY:t.clientY,isActive:this.isActive}}))}}),this.canvas.addEventListener("mouseup",()=>{this.dynamic?this.isFading=!0:this.pos=new Vector(this.origin.x,this.origin.y),this.direction=null,this.isActive=!1})}touch(){this.canvas.addEventListener("touchstart",t=>{if(this.dynamic){let e=this.canvas.getBoundingClientRect();this.origin=new Vector(t.touches[0].pageX,t.touches[0].pageY).subtract({x:e.x,y:e.y}),this.pos=new Vector(t.touches[0].pageX,t.touches[0].pageY).subtract({x:e.x,y:e.y}),this.isDisplay=!0,this.isFading=!1,this.alpha=1}this.isActive=!0}),this.canvas.addEventListener("touchmove",t=>{let e=this.canvas.getBoundingClientRect(),i=new Vector(t.touches[0].pageX,t.touches[0].pageY).subtract({x:e.x,y:e.y}).subtract(this.origin),s=Math.min(i.magnitude,this.outerRadius);this.pos.x=this.origin.x+Math.cos(i.angle)*s,this.pos.y=this.origin.y+Math.sin(i.angle)*s,this.checkSwipe(this.origin,new Vector(t.clientX,t.clientY)),this.canvas.dispatchEvent(new CustomEvent("joystick",{detail:{e:t,angle:i.angle,magnitude:i.magnitude,direction:this.direction,originX:this.origin.x,originY:this.origin.y,clientX:t.clientX,clientY:t.clientY,isActive:this.isActive}})),t.preventDefault()}),this.canvas.addEventListener("touchend",()=>{this.dynamic?this.isFading=!0:this.pos=new Vector(this.origin.x,this.origin.y),this.isActive=!1})}show(){this.dynamic?(this.isDisplay&&this.draw(),this.fadeIn()):(this.isFading=!1,this.isDisplay=!0,this.alpha=1,this.draw())}hide(){this.isDisplay=!1,this.isActive=!1}}class Component extends Vector{constructor({x:t=0,y:e=0,w:i=0,h:s=0,r:n=null,x0:h=null,y0:a=null,x1:o=null,y1:r=null}){super(t,e),this.w=i,this.h=s,this.r=n,this.x0=h,this.x1=o,this.y0=a,this.y1=r,this.vel=new Vector(0,0),this.s=0,this.m=5,this.type=null!==this.x0?"line":null!==this.r?"circle":"polygon"}getCenterX(){return"circle"===this.type?this.x:this.x+.5*this.w}getCenterY(){return"circle"===this.type?this.y:this.y+.5*this.h}}class Camera extends Vector{constructor(t=0,e=0,i=0,s=0){super(t,e),this.w=i,this.h=s,this.maxDimension=new Vector(0,0)}follow(t){if(0===this.maxDimension.y&&0===this.maxDimension.x)throw new Error("Please provide the maximum dimension for the camera");let e=new Vector(t.getCenterX(),t.getCenterY()).subtract({x:.5*this.w,y:.5*this.h});this.x=e.x,this.y=e.y,this.x=Math.min(Math.max(0,this.x),Math.min(this.maxDimension.x-this.w,Math.max(0,e.x))),this.y=Math.min(Math.max(0,this.y),Math.min(this.maxDimension.y-this.h,Math.max(0,e.y)))}}class Sprite extends Component{constructor(t,e,i,s,n,h,a=0){super({x:t,y:e,w:i,h:s}),this.data=n,this.img=this.data.img,this.tileW=this.data.w,this.tileH=this.data.h,this.spacing=this.data.spacing,this.frame=this.data.frame.filter(t=>t.name===h)[0],this.frameName="",this.currentFrame=[],this.frameIndex=0;for(const t in this.frame)this.setFrame(t);this.src=new Vector(void 0,void 0),this.delay=a,this.maximumDelay=a}setFrame(t){if(this.frameName=t,void 0===this.frame[t])throw new Error(`"${t}" is not a valid frame's name`);this.currentFrame=this.frame[t]}getFrame(){return this.frameName}animate(){if(this.currentFrame.length<1||!(this.currentFrame instanceof Array))throw new Error("Current Animation's Frame does not exist");if(this.delay--,this.delay<0){this.delay=this.maximumDelay,this.frameIndex++,this.frameIndex>=this.currentFrame.length&&(this.frameIndex=0);let t=this.currentFrame[this.frameIndex]-1;this.src=this.data.getIndex(t)}}draw(t=null){this.animate(),"function"==typeof t?t():CURRENT_CONTEXT.drawImage(this.img,this.src.x*this.data.w,this.src.y*this.data.h,this.data.w,this.data.h,this.x,this.y,this.w,this.h)}}const TileMapCollision={nextTile:[],nextTilePos:[],newPos:{x:null,y:null},checkCollision(t,e="rect",{left:i=null,right:s=null,up:n=null,down:h=null,timeElapsed:a={x:1,y:1}}){let o,r,c;if("rect"!==e)throw TypeError("only rect to rect collision checking exists");o={x:t.x,y:t.y,w:t.w,h:t.h};let l={x:t.x+t.vel.x*a.x,y:t.y+t.vel.y*a.y};t.vel.x<=0?(this.nextTilePos[0]={x:l.x,y:o.y},this.nextTilePos[1]={x:l.x,y:o.y+o.h+.9-1},r=this.getTile(this.nextTilePos[0]),c=this.getTile(this.nextTilePos[1]),this.nextTile=[r,c],this.newPos.x=parseInt(l.x),"function"==typeof i&&i()):(this.nextTilePos[0]={x:l.x+o.w-1,y:o.y},this.nextTilePos[1]={x:l.x+o.w-1,y:o.y+o.h+.9-1},r=this.getTile(this.nextTilePos[0]),c=this.getTile(this.nextTilePos[1]),this.nextTile=[r,c],this.newPos.x=parseInt(l.x),"function"==typeof s&&s()),t.vel.y<=0?(this.nextTilePos[0]={x:l.x,y:l.y},this.nextTilePos[1]={x:l.x+o.w+.9-1,y:l.y},r=this.getTile(this.nextTilePos[0]),c=this.getTile(this.nextTilePos[1]),this.nextTile=[r,c],this.newPos.y=parseInt(l.y),"function"==typeof n&&n()):(this.nextTilePos[0]={x:l.x,y:l.y+t.h-1},this.nextTilePos[1]={x:l.x+o.w+.9-1,y:l.y+o.h-1},r=this.getTile(this.nextTilePos[0]),c=this.getTile(this.nextTilePos[1]),this.nextTile=[r,c],this.newPos.y=parseInt(l.y),"function"==typeof n&&n())}};class TileMap{constructor({map:t=[0],w:e,h:i,camera:s,defs:n={default:0}}){if(this.map=t,!(this.map instanceof Array)||this.map.length<=0||this.map[0][0].length<=0)throw new Error("world map can only be respresented as a 2D Array");if(this.w=e,this.h=i,this.mapSize=new Vector(this.map[0].length,this.map.length),this.mapDimension=new Vector(this.w,this.h).multiply(this.mapSize),this.camera=s||new Camera(0,0,this.mapDimension.x,this.mapDimension.y),!(this.camera instanceof Camera))throw new Error("Failed to initialize camera: camera must be an instance of `Camera`");this.camera.maxDimension=this.mapDimension,this.id=null,this.row=null,this.col=null,this.defs=n}set(t){this.map=t}render(t){let e=~~(this.camera.x/this.w),i=~~(this.camera.y/this.h),s=Math.ceil((this.camera.x+this.camera.w)/this.w),n=Math.ceil((this.camera.y+this.camera.h)/this.h);for(let h=i;h<n;h++)for(let i=e;i<s;i++)this.id=this.map[h][i],this.row=h,this.col=i,t()}getTile(t){let e=new Vector(~~(t.x/this.w),~~(t.y/this.h));return this.map[e.y][e.x]}setTile(t,e){let i=~~(t.x/this.w),s=~~(t.y/this.h);this.map[s][i]=e}getDefs(t){if(void 0!==this.defs[t])return this.defs[t];throw new Error(`"${t}" is not a valid defs name`)}}Object.assign(TileMap.prototype,TileMapCollision);class TileSet{constructor({img:t=null,w:e=0,h:i=0,col:s=0,row:n=0,spacing:h=0,frame:a=[]}){null!==t&&(this.img=new Image,this.img.src=t),this.w=e,this.h=i,this.col=s,this.row=n,this.spacing=h,this.frame=a}getIndex(t){let e=~~(t%this.col),i=~~(t/this.col);return new Vector(e,i)}getTile(t,e){return t*this.col+e}}class Scene{constructor({canvas:t,width:e,height:i,backgroundColor:s,controls:n,backgroundImage:h}){this.canvas=t;try{this.getContext=(()=>this.canvas.getContext("2d"))}catch(t){throw new Error("Failed to initialize canvas: "+t.message)}this.width=e||300,this.height=i||300,this.canvas.width=this.width,this.canvas.height=this.height,this.controls=n||[],this.joystick=null,this.swipe=null,this.controls.forEach((t,e)=>{"swipe"===t.event?this.swipe=new Swipe({element:this.canvas,type:t.type}):"joystick"===t.event&&(this.joystick=new JoyStick({canvas:this.canvas,...t.style}))}),void 0!==s&&(this.canvas.style.backgroundColor=s),void 0!==h&&(this.canvas.style.backgroundImage=`url(${h})`,this.canvas.backgroundSize="cover"),this.startLoop=(t=>requestAnimationFrame(t)),this.elapsedTime=0,this.animationFrame=null,this.timeEnded=null,this.timeStarted=null,this.fps=null,Scene.setScene(this),Scene.setContext(this.canvas)}calcFps(){this.timeEnded=performance.now(),this.fps=1e3/(this.timeEnded-this.timeStarted),this.timeStarted=this.timeEnded}mainLoop(t){const e=i=>{this.elapsedTime=i,this.animationFrame=e,t()};this.startLoop(e)}static setContext(t){try{CURRENT_CONTEXT=t.getContext("2d")}catch(t){throw new Error(`Failed to set the global variable "CURRENT_CONTEXT": ${t.message}`)}}static setScene(t){if(!(t instanceof Scene))throw TypeError(`"${t}" must be an instance of Scene`);CURRENT_SCENE=t}}
