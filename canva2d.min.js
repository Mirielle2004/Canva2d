/**
 * Name         : Canva2d.js
 * @author      : Mirielle S. (codeBreaker!)
 * Last Modified: 26.06.2020
 * Revision     : 0.0.1
 * Minified with tersser
 * @url https://gist.github.com/gaearon/42a2ffa41b8319948f9be4076286e1f3
 * 
 * MIT License
 * 
 * Copyright (c) 2020 CodeBreaker
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 */
CanvasRenderingContext2D.prototype.__proto__={clearColor(t,i,e,s,h){this.fillStyle=h,void 0!==h?this.fillRect(t,i,e,s):this.clearRect(t,i,e,s)}};const Vector=function(t,i){this.x=t,this.y=i,this.magnitude=Math.hypot(this.x,this.y),this.angle=0};Vector.prototype={normalise(){let t=this.magnitude();this.x/=t,this.y/=t},add(t){let i=this.x+t.x,e=this.y+t.y;return new Vector(i,e)},subtract(t){let i=this.x-t.x,e=this.y-t.y;return new Vector(i,e)},scalarMultiplication(t){let i=this.x*t,e=this.y*t;return new Vector(i,e)},dot(t){return this.x*t.x+this.y*t.y},scaleOperation(t,i){if("+"===i)return new Vector(this.x+t,this.y+t);if("-"===i)return new Vector(this.x-t,this.y-t);if("/"===i)return new Vector(this.x/t,this.y/t);throw"Invalid Operation's request on a Vector"}};class Scene{constructor(t){this.canvas=t.canvas||null;try{this.ctx=this.canvas.getContext("2d")}catch(t){throw"Failed to initialize canvas"}this.width=t.width||300,this.height=t.height||300,this.canvas.width=this.width,this.canvas.height=this.height,this.update=t.update||null,this.debug=t.debug||!0,"undefined"!==t.backgroundColor&&(this.canvas.style.backgroundColor=t.backgroundColor),this.checkDebug(console.log,"Scene created succesfully"),this.currentTime=0,this.animationFrame=null}checkDebug(t,i){this.debug&&t(i)}mainLoop(t){this.checkDebug(console.log,"mainLoop's started");const i=e=>{this.currentTime=e,this.animationFrame=i,t()};requestAnimationFrame(i)}}class Collision{static rect(t,i){return i.x+i.w>t.x&&t.x+t.w>i.x&&i.y+i.h>t.y&&t.y+t.h>i.y}}class Component extends Vector{constructor(t=0,i=0,e=0,s=0){super(t,i),this.w=e,this.h=s,this.isJumping=!1,this.jumpCounter=0}linearJump(t){this.isJumping&&(0===this.jumpCounter?(this.y-=t.velY,this.y-this.h<t.maxHeight&&(this.jumpCounter=1)):(t.velY+=t.gravity,this.y+=t.velY,this.y+this.h>t.minHeight&&(this.isJumping=!1,t.velY=0,this.jumpCounter=0)))}}
